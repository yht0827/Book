# DB 설계와 쿼리 성능 최적화

## 개요

DB 성능은 연동하는 모든 서버 성능에 영향을 미칩니다. 대부분의 DB 성능 문제는 DB 자체보다는 **잘못된 사용**에서 발생합니다.

---

## 1. 인덱스 설계

### 1.1 조회 트래픽을 고려한 인덱스 설계

- 일반적인 시스템에서는 조회 기능의 실행 비율이 높음
- DB 테이블 설계 시 **조회 패턴과 트래픽 규모**를 반드시 고려
- 풀 스캔을 방지하려면 조회 패턴 기준으로 인덱스 설계 필요

### 1.2 단일 인덱스 vs 복합 인덱스

**예시 테이블:**
```sql
CREATE TABLE activityLog (
    id integer(10) NOT NULL AUTO_INCREMENT,
    userId integer(10) NOT NULL,
    activityType varchar(20) NOT NULL,
    activityDate date NOT NULL,
    activityDatetime timestamp NOT NULL,
    memo varchar(200)
);
```

**쿼리 예시 1:**
```sql
SELECT * FROM activityLog
WHERE userId = 123 AND activityDate = '2024-07-31'
ORDER BY activityDatetime DESC;
```

**고민 포인트:**
- **단일 인덱스**: `userId`만 인덱스 생성
- **복합 인덱스**: `(userId, activityDate)` 함께 인덱스 생성
- → 사용자의 일별 활동 데이터 조회 패턴을 기준으로 결정

**쿼리 예시 2:**
```sql
SELECT activityDate, activityType, COUNT(activityType)
FROM activityLog
WHERE activityDate = '2024-07-28'
GROUP BY activityType;
```

**커버링 인덱스 활용:**
- `activityType`까지 인덱스에 추가하면 커버링 인덱스로 처리 가능
- 데이터가 많을 경우 조회 시간 대폭 단축

### 1.3 선택도(Selectivity)를 고려한 인덱스 컬럼 선택

- **선택도**: 인덱스에서 특정 컬럼의 고유한 값 비율 (카디널리티와 유사)
- 선택도가 높은 컬럼을 인덱스로 선택하는 것이 효과적

### 1.4 커버링 인덱스 활용

- 특정 쿼리 실행에 필요한 **모든 컬럼을 포함**하는 인덱스
- 테이블 접근 없이 인덱스만으로 쿼리 처리 가능

### 1.5 인덱스는 필요한 만큼만

**인덱스 관리 비용 고려:**
- 인덱스 생성/유지에도 비용 발생
- **조회 > 추가/수정/삭제** 비율일 때 효과적
- 그 외의 경우 오히려 성능 저하 요인이 될 수 있음

---

## 2. 조회 성능 개선 방법

### 2.1 미리 집계하기

- `COUNT`, `SUM` 같은 집계 쿼리를 조회 시점에 실행하면 성능 문제 발생
- **해결책**: 집계 데이터를 미리 계산해서 별도 컬럼에 저장

**고려사항:**
1. **비정규화**: 성능을 위해 약간의 불일치를 감수할 수 있음
2. **동시성 문제**: 비정규화 시 동시성 제어 필수

### 2.2 ID 기준 목록 조회 (Zero-Offset 방식)

- `OFFSET` 사용 시 offset만큼 데이터 스캔 → 성능 저하
- **개선**: 클러스터 인덱스인 `id` 기준 zero-offset 방식 사용

**기존 방식:**
```sql
SELECT * FROM posts ORDER BY id DESC LIMIT 10 OFFSET 100;
```

**개선 방식:**
```sql
SELECT * FROM posts WHERE id < 최종조회ID ORDER BY id DESC LIMIT 10;
```

### 2.3 조회 범위를 시간 기준으로 제한

- 조회 범위를 시간 기준으로 제한하여 성능 개선
- 최신 데이터 기준 조회로 스캔 범위 축소

### 2.4 전체 개수 세지 않기

**문제점:**
- 데이터가 많을수록 `COUNT` 쿼리 실행 시간 증가
- 조건에 해당하는 모든 테이블/인덱스 스캔 필요

**대안:**
- 대략적인 개수만 표시 (예: "100개 이상")
- 첫 페이지에만 전체 개수 표시

### 2.5 오래된 데이터 삭제 및 분리 보관

- 데이터 증가 → 쿼리 실행 시간 증가
- **과거 데이터 삭제**로 데이터 개수 일정하게 유지
- 성능을 일정 수준으로 유지 가능

### 2.6 DB 장비 확장

**수직 확장(Scale-up):**
- 더 빠른 CPU, 더 많은 메모리로 교체
- 즉각적인 성능 향상 효과

**수평 확장(Scale-out):**
- **Primary-Replica 구조** (주 DB - 복제 DB)
- 조회 트래픽 비중이 높은 서비스에 효과적
- CQRS 패턴 적용 가능

### 2.7 별도 캐시 서버 구성

**장점:**
- DB 확장 대비 적은 비용으로 더 많은 트래픽 처리
- Redis 같은 캐시 서버 구성이 DB 확장보다 부담 적음

**단점:**
- 캐시 도입 시 코드 수정 필요

---

## 3. 주의 사항

### 3.1 쿼리 타임아웃 설정

- DB 서버가 쿼리 실행 시간을 제한하는 설정
- 쿼리가 너무 오래 걸릴 경우 중단하고 오류 반환
- DB 서버 과부하 방지

**서비스 특성별 설정:**
- **블로그 조회**: 짧은 타임아웃 (몇 초)
- **결제 처리**: 긴 타임아웃 필요 (데이터 정합성 이슈 방지)

### 3.2 상태 변경 기능은 복제 DB에서 조회 금지

**Primary-Replica 구조 사용 시:**
- 변경: Primary DB
- 조회: Replica DB

**문제점:**
1. **복제 지연(Replication Lag)**
   - Primary → Replica 데이터 전달 시간 소요
   - 네트워크 전송 + 반영 시간
   - 지연 시간 동안 Primary와 Replica가 다른 값 보유

2. **트랜잭션 문제**
   - 상태 변경 후 즉시 조회 시 예전 데이터 조회 가능

### 3.3 배치 쿼리 실행 시간 관리

**문제:**
- 조회/집계 데이터 양 증가 → 실행 시간 증가
- 특정 임계점 초과 시 실행 시간 급증

**해결책:**
1. DB 장비 사양 향상
2. 커버링 인덱스 활용
3. 데이터를 일정 크기로 나눠 처리(Chunk 처리)

### 3.4 타입이 다른 컬럼 조인 주의

- 조인하는 두 컬럼의 타입이 다르면 인덱스 활용 불가
- 타입 일치 필수

**예시:**
```sql
-- 잘못된 예: userId가 INT와 VARCHAR로 다른 경우
SELECT * FROM orders o
JOIN users u ON o.userId = u.userId;  -- 인덱스 활용 불가
```

### 3.5 테이블 변경은 신중하게

**주의 이유:**
- MySQL의 테이블 변경 방식:
  1. 새 테이블 생성
  2. 원본 데이터 복사
  3. 복사 완료 후 새 테이블로 대체

**문제:**
- 복사 중 `UPDATE`, `INSERT`, `DELETE` 작업 차단
- 데이터가 많으면 서비스 장시간 중단 가능

**대안:**
- Online DDL 도구 사용 (pt-online-schema-change 등)
- 점진적 마이그레이션

---

## 4. 트랜잭션 처리

### 4.1 트랜잭션 필수 고려

- 모든 코드가 항상 정상 동작하는 것은 아님
- **비정상 상황에서의 트랜잭션 처리** 반드시 고민

### 4.2 자주 발생하는 실수

**1. 트랜잭션 없이 여러 데이터 수정**
```java
// 잘못된 예
updateUserStatus(userId);
updateOrderStatus(orderId);
sendNotification(userId);  // 이 부분에서 실패 시?
```

**2. 외부 API와 DB 작업 혼재**
- 외부 API 호출 성공 + DB 작업 실패
- 반대로 DB 작업 성공 + 외부 API 실패

**해결 방안:**
- 트랜잭션 범위 명확히 정의
- 보상 트랜잭션(Saga 패턴) 고려
- 멱등성 보장

---

## 요약

### 인덱스 설계
- 조회 패턴 기반 인덱스 설계
- 복합 인덱스 vs 단일 인덱스 검토
- 커버링 인덱스 활용 가능성 검토
- 선택도 높은 컬럼 우선 선택

### 쿼리 최적화
- 집계 데이터 미리 계산
- Zero-offset 방식 사용
- 조회 범위 시간 제한
- COUNT 쿼리 최소화
- 오래된 데이터 정리

### 인프라
- 적절한 캐시 전략 수립
- Primary-Replica 구조 검토
- 쿼리 타임아웃 설정

### 안정성
- 트랜잭션 범위 명확히 정의
- 복제 지연 고려한 설계
- 테이블 변경 시 Online DDL 검토